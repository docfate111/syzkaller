# Copyright 2020 syzkaller project authors. All rights reserved.
# Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.

include <uapi/linux/fs.h>
include <linux/f2fs_fs.h>
include <fs/f2fs/f2fs.h>
include <uapi/linux/f2fs.h>

ioctl$FS_IOC_GETVERSION(fd fd, cmd const[FS_IOC_GETVERSION], arg ptr[out, int32])
ioctl$F2FS_IOC_START_ATOMIC_WRITE(fd fd, cmd const[F2FS_IOC_START_ATOMIC_WRITE], arg const[0])
ioctl$F2FS_IOC_COMMIT_ATOMIC_WRITE(fd fd, cmd const[F2FS_IOC_COMMIT_ATOMIC_WRITE], arg const[0])
ioctl$F2FS_IOC_START_VOLATILE_WRITE(fd fd, cmd const[F2FS_IOC_START_VOLATILE_WRITE], arg const[0])
ioctl$F2FS_IOC_RELEASE_VOLATILE_WRITE(fd fd, cmd const[F2FS_IOC_RELEASE_VOLATILE_WRITE], arg const[0])
ioctl$F2FS_IOC_ABORT_VOLATILE_WRITE(fd fd, cmd const[F2FS_IOC_ABORT_VOLATILE_WRITE], arg const[0])
ioctl$F2FS_IOC_GARBAGE_COLLECT(fd fd, cmd const[F2FS_IOC_GARBAGE_COLLECT], arg ptr[in, bool32])
ioctl$F2FS_IOC_GARBAGE_COLLECT_RANGE(fd fd, cmd const[F2FS_IOC_GARBAGE_COLLECT_RANGE], arg ptr[in, f2fs_gc_range])
ioctl$F2FS_IOC_WRITE_CHECKPOINT(fd fd, cmd const[F2FS_IOC_WRITE_CHECKPOINT], arg const[0])
ioctl$F2FS_IOC_DEFRAGMENT(fd fd, cmd const[F2FS_IOC_DEFRAGMENT], arg ptr[inout, f2fs_defragment])
ioctl$F2FS_IOC_MOVE_RANGE(fd fd, cmd const[F2FS_IOC_MOVE_RANGE], arg ptr[inout, f2fs_move_range])
ioctl$F2FS_IOC_FLUSH_DEVICE(fd fd, cmd const[F2FS_IOC_FLUSH_DEVICE], arg ptr[in, f2fs_flush_device])
ioctl$F2FS_IOC_GET_FEATURES(fd fd, cmd const[F2FS_IOC_GET_FEATURES], arg ptr[out, int32])
ioctl$F2FS_IOC_GET_PIN_FILE(fd fd, cmd const[F2FS_IOC_GET_PIN_FILE], arg ptr[out, bool32])
ioctl$F2FS_IOC_SET_PIN_FILE(fd fd, cmd const[F2FS_IOC_SET_PIN_FILE], arg ptr[in, bool32])
ioctl$F2FS_IOC_PRECACHE_EXTENTS(fd fd, cmd const[F2FS_IOC_PRECACHE_EXTENTS], arg const[0])
ioctl$F2FS_IOC_RESIZE_FS(fd fd, cmd const[F2FS_IOC_RESIZE_FS], arg ptr[in, int64])
ioctl$F2FS_IOC_GET_COMPRESS_BLOCKS(fd fd, cmd const[F2FS_IOC_GET_COMPRESS_BLOCKS], arg ptr[out, int64])
ioctl$F2FS_IOC_RELEASE_COMPRESS_BLOCKS(fd fd, cmd const[F2FS_IOC_RELEASE_COMPRESS_BLOCKS], arg ptr[out, int64])
ioctl$F2FS_IOC_RESERVE_COMPRESS_BLOCKS(fd fd, cmd const[F2FS_IOC_RESERVE_COMPRESS_BLOCKS], arg ptr[out, int64])
ioctl$FITRIM(fd fd, cmd const[FITRIM], arg ptr[in, fstrim_range])
ioctl$FS_IOC_SET_ENCRYPTION_POLICY(fd fd, cmd const[FS_IOC_SET_ENCRYPTION_POLICY], arg ptr[in, int8])
ioctl$FS_IOC_GET_ENCRYPTION_POLICY(fd fd, cmd const[FS_IOC_GET_ENCRYPTION_POLICY], arg ptr[out, fscrypt_context])
ioctl$FS_IOC_ADD_ENCRYPTION_KEY(fd fd, cmd const[FS_IOC_ADD_ENCRYPTION_KEY], arg ptr[in, fscrypt_key_specifier])
ioctl$FS_IOC_REMOVE_ENCRYPTION_KEY(fd fd, cmd const[FS_IOC_REMOVE_ENCRYPTION_KEY], arg ptr[in, fscrypt_remove_key_arg])
ioctl$FS_IOC_ENABLE_VERITY(fd fd, cmd const[FS_IOC_ENABLE_VERITY], arg ptr[in, fsverity_enable_arg])
ioctl$FS_IOC_MEASURE_VERITY(fd fd, cmd const[FS_IOC_MEASURE_VERITY], arg ptr[in, fsverity_digest])
ioctl$FS_IOC_READ_VERITY_METADATA(fd fd, cmd const[FS_IOC_READ_VERITY_METADATA], arg ptr[in, fsverity_read_metadata_arg])
ioctl$FS_IOC_SETFSLABEL(fd fd, cmd const[FS_IOC_SETFSLABEL], arg string)
ioctl$F2FS_IOC_SEC_TRIM_FILE(fd fd, cmd const[F2FS_IOC_SEC_TRIM_FILE], arg ptr[in, f2fs_sectrim_range])
ioctl$F2FS_IOC_GET_COMPRESS_OPTION(fd fd, cmd const[F2FS_IOC_GET_COMPRESS_OPTION], arg ptr[in, f2fs_comp_option])
ioctl$F2FS_IOC_DECOMPRESS_FILE(fd fd, cmd const[F2FS_IOC_DECOMPRESS_FILE], arg const[0])
ioctl$F2FS_IOC_COMPRESS_FILE(fd fd, cmd const[F2FS_IOC_COMPRESS_FILE], arg const[0])
# F2FS_IOC_SHUTDOWN on root fs effectively brings the machine down in weird ways.
# Fortunately, the value does not conflict with any other ioctl commands for now.
ioctl$F2FS_IOC_SHUTDOWN(fd fd, cmd const[F2FS_IOC_SHUTDOWN], args ptr[in, flags[f2fs_shutdown_flag, int32]]) (disabled)

f2fs_comp_option {
	algorithm int8
	log_cluster_size int8
}

f2fs_sectrim_range {
	flags int64
	len int64
	start int64
}

fseverify_digest {
	digest_algorithm int16
	digest_size int16
	digest array[int8]
}

fsverity_read_metadata_arg {
	metadata_type int64[1:3]
	offset int64
	length int64
	buf_ptr int64
	__reserved int64
}

salt {
	salt array[int8, 32]
}

sig {
	sig array[int8, 32]
}

fsverity_enable_arg {
	version int32
	hash_algorithm int32
	block_size int32
	salt_size int32
	salt_ptr ptr[in, salt]
	sig_size int32
	__reserved1 int32
	sig_ptr ptr[in, sig]
	__reserved2 array[int64, 11]
}

f2fs_gc_range {
	sync int32
	start int64
	len int64
}

fscrypt_get_key_status_arg {
	key_spec fscrypt_key_specifier
	__reserved array[int32, 6]
	status int32
	user_count int32
	__out_reserved array[int32, 13]
}

fscrypt_key_specifier {
	type int32
	reserved int32
	union {
		__reserved array[int8, 32]
		descriptor[int8, 8]
		identifier[int8, 8]
	}
}

fscrypt_add_key_arg {
	key_spec fscrypt_key_specifier
	raw_size int32
	key_id int32
	reserved array[int32, 8]
	raw array[int8]
}

fscrypt_remove_key_arg {
	key_spec fscrypt_key_specifier
	removal_status_flags int32
	reserved array[int32, 5]
}

fscrypt_context {
	version int8
	v1 fscrypt_context_v1
	v2 fscrypt_context_v2
}

fscrypt_context_v1 {
	version int8
	contents_encryption_mode int8
	filenames_encryption_mode int8
	flags int8
	master_key_descriptor array[int8, 8]
	nonce array[int8, 16]
}

fscrypt_context_v2 {
	version int8
	contents_encryption_mode int8
	filenames_encryption_mode int8
	flags int8
	master_key_descriptor array[int8, 8]
	nonce array[int8, 16]
}

fstrim_range {
	start int64
	len int64
	minlen int64
}

f2fs_gc_range {
	sync	bool32
	start	int64
	len	int64
}

f2fs_defragment {
	start	int64
	len	int64
}

f2fs_move_range {
	dst_fd	fd
	pos_in	int64
	pos_out	int64
	len	int64
}

f2fs_flush_device {
	dev_num		int32
	segments	int32
}

f2fs_shutdown_flag = F2FS_GOING_DOWN_FULLSYNC, F2FS_GOING_DOWN_METASYNC, F2FS_GOING_DOWN_NOSYNC, F2FS_GOING_DOWN_METAFLUSH, F2FS_GOING_DOWN_NEED_FSCK
